const express = require('express');
const { Innertube, UniversalCache, Utils } = require('youtubei.js');
const { spawn } = require("child_process");
const fs = require('fs').promises;
const path = require('path');
const bytes = require('bytes');
require("dotenv").config();
const app = express();

// Configuration
const PORT = process.env.PORT || 3000;
const tmpDir = process.env.TMP_DIR || './downloaded';
const YT_COOKIE = process.env.YT_COOKIE || '';

// Ensure tmp directory exists
(async () => {
  try {
    await fs.mkdir(tmpDir, { recursive: true });
  } catch (error) {
    console.error('Failed to create tmp directory:', error);
  }
})();

// Utility functions
const formatSize = (n) => bytes(+n, { unitSeparator: ' ' });
const generateRandomId = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);

const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/|youtube\.com\/(?:v|e(?:mbed)?)\/|youtube\.com\/watch\?v=)([a-zA-Z0-9_-]{11})|(?:https?:\/\/)?(?:www\.)?youtube\.com\/shorts\/([a-zA-Z0-9_-]{11})/;

// Task storage
const tasks = {};

class YouTubeKAH {
  // Video info method
  info = async function ytinfo(url) {
    try {
      console.log(`- Getting info ${url} ....`);
      const match = url.match(youtubeRegex);
      const videoId = match ? match[1] || match[2] : null;
      
      if (!videoId) {
        throw new Error("Invalid YouTube URL");
      }

      const yt = await Innertube.create({ 
        cache: new UniversalCache(false), 
        generate_session_locally: true, 
        cookie: YT_COOKIE
      });

      const video = await yt.getInfo(videoId, 'WEB_EMBEDDED');
      const pk = video.streaming_data.adaptive_formats;
      let videos = [];
      let audios = [];
      
      for (const item of pk) {
        let fileSize = '0 B';
        if (item?.content_length) {
          let size, unit;
          if (item?.content_length >= 1024 ** 3) { 
            size = item?.content_length / (1024 ** 3);
            unit = 'GB';
          } else if (item?.content_length >= 1024 ** 2) { 
            size = item?.content_length / (1024 ** 2);
            unit = 'MB';
          } else if (item?.content_length >= 1024) { 
            size = item?.content_length / 1024;
            unit = 'KB';
          } else {
            size = item?.content_length;
            unit = 'B';
          }
          fileSize = `${size.toFixed(2)} ${unit}`;
        }
        
        if (item.mime_type.includes("video/mp4")) {
          videos.push({
            itag: item.itag,
            quality: item.quality,
            quality_label: item.quality_label,
            bitrate: item.bitrate,
            average_bitrate: item.average_bitrate,
            mime_type: item.mime_type,
            file_size: fileSize
          });
        }
        
        if (item.mime_type.includes("audio/mp4")) {
          audios.push({
            itag: item.itag,
            quality: item.quality,
            quality_label: item.quality_label,
            bitrate: item.bitrate,
            average_bitrate: item.average_bitrate,
            mime_type: item.mime_type,
            file_size: fileSize
          });
        }
      }
      
      return {
        info: video.basic_info,
        videos,
        audios
      };
    } catch (e) {
      console.error("Terjadi kesalahan:", e);
      return {
        error: "Failed to retrieve data",
        info: {},
        videos: [],
        audios: []
      };
    }
  }

  // Audio processing arguments
  getAudioProcessArgs = function (inputPath, outputPath, randomId) {
    return [
      '-loglevel', 'error',
      '-i', inputPath,
      '-c:a', 'aac',
      '-b:a', '128k',
      '-ac', '2',
      '-ar', '44100',
      '-movflags', 'faststart',
      '-metadata', 'title=' + `audio_${randomId}`,
      '-metadata', 'comment=Generated by PaxSenixAPI',
      '-f', 'mp4',
      outputPath
    ];
  }

  getHighQualityAudioArgs = function (inputPath, outputPath, randomId) {
    return [
      '-loglevel', 'error',
      '-i', inputPath,
      '-c:a', 'aac',
      '-b:a', '192k',
      '-ac', '2',
      '-ar', '48000',
      '-movflags', 'faststart',
      '-metadata', 'title=' + `audio_${randomId}`,
      '-metadata', 'comment=Generated by PaxSenixAPI',
      '-metadata', 'genre=Audio',
      '-f', 'mp4',
      outputPath
    ];
  }

  // Audio download method
  mp3 = async function ytmp3(req, url, quality, randomId) {
    console.log(`- Downloading audio for ${url} with ID ${randomId} ....`);
    const match = url.match(youtubeRegex);
    const videoId = match ? match[1] || match[2] : null;

    if (!videoId) {
      throw new Error("Video ID tidak valid. Pastikan URL YouTube benar.");
    }

    try {
      const rawAudioPath = `${tmpDir}/raw_audio_${randomId}.m4a`;
      const processedAudioPath = `${tmpDir}/audio_${randomId}.m4a`;

      const yt = await Innertube.create({ 
        cache: new UniversalCache(false), 
        generate_session_locally: true, 
        cookie: YT_COOKIE
      });

      const audioStream = await yt.download(videoId, {
        type: 'audio',
        quality: 'best',
        format: 'mp4',
        client: 'WEB_EMBEDDED'
      });

      console.log('- Saving raw audio stream...');
      await new Promise(async (resolve) => {
        const audioFile = require('fs').createWriteStream(rawAudioPath);
        for await (const chunk of Utils.streamToIterable(audioStream)) {
          audioFile.write(chunk);
        }
        audioFile.end();
        audioFile.on('finish', resolve);
      });

      console.log('- Processing audio with ffmpeg...');

      const useHighQuality = quality === 'high' || quality === '192k';
      const args = useHighQuality 
        ? this.getHighQualityAudioArgs(rawAudioPath, processedAudioPath, randomId)
        : this.getAudioProcessArgs(rawAudioPath, processedAudioPath, randomId);

      await new Promise((resolve, reject) => {
        const processAudio = spawn('ffmpeg', args, { 
          stdio: ['ignore', 'pipe', 'pipe'],
          env: { ...process.env, OMP_NUM_THREADS: '2' }
        });

        let errorOutput = '';
        processAudio.stderr.on('data', (data) => {
          errorOutput += data.toString();
        });

        processAudio.on('close', (code) => {
          if (code === 0) {
            console.log(`Processed audio saved to ${processedAudioPath}`);
            resolve();
          } else {
            console.error('ffmpeg error output:', errorOutput);
            reject(new Error(`ffmpeg process failed with code ${code}`));
          }
        });
      });

      await fs.unlink(rawAudioPath);

      const fileStats = await fs.stat(processedAudioPath);
      const fileSize = fileStats.size;
      console.log(`Audio file size: ${formatSize(fileSize)}`);

      return {
        fileSize: formatSize(fileSize),
        url: `https://${req.hostname}/file/audio_${randomId}.m4a`,
        filename: `audio_${randomId}.m4a`
      };
    } catch (error) {
      console.error("Terjadi kesalahan:", error);
      await Promise.allSettled([
        fs.unlink(`${tmpDir}/raw_audio_${randomId}.m4a`).catch(() => {}),
        fs.unlink(`${tmpDir}/audio_${randomId}.m4a`).catch(() => {})
      ]);

      throw error;
    }
  }

  // Video merging arguments
  getOptimizedMergeArgs = function (videoPath, audioPath, outputPath, randomId) {
    return [
      '-loglevel', 'error',
      '-i', videoPath,
      '-i', audioPath,
      '-map', '0:v',
      '-map', '1:a',
      '-c:v', 'copy',
      '-c:a', 'copy',
      '-movflags', 'faststart+frag_keyframe+empty_moov',
      '-avoid_negative_ts', 'make_zero',
      '-fflags', '+genpts',
      '-metadata', 'title=' + `video_${randomId}.mp4`,
      '-metadata', 'comment=Generated by PaxSenixAPI',
      '-f', 'mp4',
      outputPath
    ];
  }

  getReliableMergeArgs = function (videoPath, audioPath, outputPath, randomId) {
    return [
      '-loglevel', 'error',
      '-i', videoPath,
      '-i', audioPath,
      '-map', '0:v:0',
      '-map', '1:a:0',
      '-c:v', 'copy',
      '-c:a', 'copy',
      '-avoid_negative_ts', 'make_zero',
      '-fflags', '+genpts+discardcorrupt',
      '-vsync', 'cfr',
      '-shortest',
      '-movflags', 'faststart',
      '-metadata', 'title=' + `video_${randomId}.mp4`,
      '-metadata', 'comment=Generated by PaxSenixAPI',
      outputPath
    ];
  }

  getFastReencodeArgs = function (videoPath, audioPath, outputPath, randomId) {
    return [
      '-loglevel', 'error',
      '-i', videoPath,
      '-i', audioPath,
      '-map', '0:v',
      '-map', '1:a',
      '-c:v', 'libx264',
      '-preset', 'ultrafast',
      '-crf', '23',
      '-c:a', 'aac',
      '-b:a', '128k',
      '-ac', '2',
      '-movflags', 'faststart+frag_keyframe+empty_moov',
      '-avoid_negative_ts', 'make_zero',
      '-fflags', '+genpts',
      '-metadata', 'title=' + `video_${randomId}.mp4`,
      '-metadata', 'comment=Generated by PaxSenixAPI',
      '-pix_fmt', 'yuv420p',
      '-f', 'mp4',
      outputPath
    ];
  }

  // Video download method
  mp4 = async function ytmp4(req, url, reso, randomId) {
    const match = url.match(youtubeRegex);
    const videoId = match ? match[1] || match[2] : null;
    // ganti di awal mp4()
const videoPath = `${tmpDir}/raw_video_${randomId}.mp4`;
const audioPath = `${tmpDir}/raw_audio_${randomId}.m4a`;
const outputPath = `${tmpDir}/video_${randomId}.mp4`;


    if (!videoId) {
      throw new Error("Invalid YouTube URL");
    }

    try {
      console.log(`- Downloading ${url} with ID ${randomId} ....`);
      const yt = await Innertube.create({ 
        cache: new UniversalCache(false), 
        generate_session_locally: true, 
        cookie: YT_COOKIE
      });

      console.log(`- Downloading Video and Audio in parallel for ${url} ....`);

      const [videoStream, audioStream] = await Promise.all([
        yt.download(videoId, {
          type: 'video',
          quality: reso,
          format: 'mp4',
          client: 'WEB_EMBEDDED'
        }),
        yt.download(videoId, {
          type: 'audio',
          quality: 'best',
          format: 'mp4',
          client: 'WEB_EMBEDDED'
        })
      ]);

      await Promise.all([
        new Promise(async (resolve) => {
          const videoFile = require('fs').createWriteStream(videoPath);
          for await (const chunk of Utils.streamToIterable(videoStream)) {
            videoFile.write(chunk);
          }
          videoFile.end();
          videoFile.on('finish', resolve);
        }),
        new Promise(async (resolve) => {
          const audioFile = require('fs').createWriteStream(audioPath);
          for await (const chunk of Utils.streamToIterable(audioStream)) {
            audioFile.write(chunk);
          }
          audioFile.end();
          audioFile.on('finish', resolve);
        })
      ]);

      console.log(`- Fast merging starting...`);

      let args = this.getReliableMergeArgs(videoPath, audioPath, outputPath, randomId);

      try {
        await new Promise((resolve, reject) => {
          const processIh = spawn('ffmpeg', args, { 
            stdio: ['ignore', 'pipe', 'pipe'],
            env: { ...process.env, OMP_NUM_THREADS: '4' }
          });

          processIh.stderr.on('data', (data) => {
            const output = data.toString();
            if (output.includes('Codec not currently supported') || 
              output.includes('Invalid data found')) {
              reject(new Error('Stream copy failed'));
            }
          });

          processIh.on('close', (code) => {
            if (code === 0) {
              console.log(`Fast merged file saved to ${outputPath}`);
              resolve();
            } else {
              reject(new Error('Stream copy failed'));
            }
          });
        });
      } catch (streamCopyError) {
        console.log('Stream copy failed, falling back to fast re-encode...');

        args = this.getFastReencodeArgs(videoPath, audioPath, outputPath, randomId);

        await new Promise((resolve, reject) => {
          const processIh = spawn('ffmpeg', args, { 
            stdio: ['ignore', 'pipe', 'pipe'],
            env: { ...process.env, OMP_NUM_THREADS: '4' }
          });

          processIh.stderr.on('data', (data) => console.error(data.toString()));

          processIh.on('close', (code) => {
            if (code === 0) {
              console.log(`Re-encoded merged file saved to ${outputPath}`);
              resolve();
            } else {
              console.error("ffmpeg process failed.");
              reject(new Error('ffmpeg process failed'));
            }
          });
        });
      }

      await Promise.all([
  fs.unlink(videoPath).catch(() => {}),
  fs.unlink(audioPath).catch(() => {})
]);

      const fileStats = await fs.stat(outputPath);
      const fileSize = fileStats.size;
      console.log(`File size: ${fileSize} bytes`);

      return {
        fileSize: formatSize(fileSize),
        url: `https://${req.hostname}/file/video_${randomId}.mp4`,
        filename: `video_${randomId}.mp4`
      };
    } catch (error) {
      console.error("Error occurred:", error);
      await Promise.allSettled([
        fs.unlink(videoPath).catch(() => {}),
        fs.unlink(audioPath).catch(() => {}),
        fs.unlink(outputPath).catch(() => {})
      ]);
      throw error;
    }
  }
}

// Process function
const processTask = async (req, id, url, format, quality) => {
  try {
    const kek = new YouTubeKAH();
    const randomId = generateRandomId();
    let ok;
    if (format === "audio") {
      ok = await kek.mp3(req, url, quality, randomId);
    } else if (format === "video") {
      ok = await kek.mp4(req, url, quality, randomId);
    }
    tasks[id] = { 
      status: 'done', 
      ...ok
    };
  } catch (error) {
    console.error('Error:', error.message);
    tasks[id] = { status: 'failed', result: 'your task is failed unfortunately...' };
  }
};

// Middleware
app.use(express.json());
app.use('/file', express.static(tmpDir));

// Routes
app.get('/', (req, res) => {
  res.json({
    message: 'YouTube Downloader API',
    endpoints: {
      'GET /info': 'Get video info',
      'POST /download': 'Start download task',
      'GET /status/:id': 'Check task status',
      'GET /file/:filename': 'Download file'
    }
  });
});

// Get video info
app.get('/info', async (req, res) => {
  const { url } = req.query;
  
  if (!url) {
    return res.status(400).json({ error: 'URL parameter is required' });
  }

  try {
    const downloader = new YouTubeKAH();
    const info = await downloader.info(url);
    res.json(info);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Start download task
app.post('/download', async (req, res) => {
  const { url, format, quality } = req.body;
  
  if (!url || !format) {
    return res.status(400).json({ error: 'URL and format are required' });
  }

  if (!['audio', 'video'].includes(format)) {
    return res.status(400).json({ error: 'Format must be "audio" or "video"' });
  }

  const id = Date.now().toString();
  tasks[id] = { status: 'processing' };

  // Start processing in background
  processTask(req, id, url, format, quality);

  res.json({
    taskId: id,
    status: 'processing',
    message: 'Download started. Check status with /status/:id'
  });
});

// Check task status
app.get('/status/:id', (req, res) => {
  const { id } = req.params;
  const task = tasks[id];
  
  if (!task) {
    return res.status(404).json({ error: 'Task not found' });
  }
  
  res.json(task);
});

// Cleanup old files endpoint (optional)
app.post('/cleanup', async (req, res) => {
  try {
    const files = await fs.readdir(tmpDir);
    const now = Date.now();
    let deletedCount = 0;
    
    for (const file of files) {
      const filePath = path.join(tmpDir, file);
      const stats = await fs.stat(filePath);
      // Delete files older than 1 hour
      if (now - stats.mtimeMs > 60 * 60 * 1000) {
        await fs.unlink(filePath);
        deletedCount++;
      }
    }
    
    res.json({ message: `Deleted ${deletedCount} old files` });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Start server
app.listen(PORT, () => {
  console.log(`YouTube Downloader API running on port ${PORT}`);
});
